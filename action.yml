name: cdktf-diff
description: Execute cdktf diff, parse STDOUT/STDERR output, and return outputs based on the outcomes.
inputs:
  github_token:
    description: GITHUB_TOKEN to use GitHub API. Simply specify secrets.GITHUB_TOKEN.
    required: true
  job_name:
    description: jobs.<job-id>.name of this workflow job. This is needed to get the job ID via query.
    required: true
  output_filename:
    description: Name of the file this jobs outputs will be saved into.
    required: true
  ref:
    description: The ref (branch or sha) to use with the diff.
    required: true
  stack:
    description: Full name of the CDKTF stack to diff.
    required: true
  stub_output_file:
    description: When present, no Terraform will execute. The output of this action will be substituted with the output contained in this file. This is useful for cases when you want to test but don't have authentication set up.
  terraform_version:
    default: 1.8.0
    description: The version of Terraform to use
  working_directory:
    default: ./
    description: Working directory path that contains your cdktf code.
  skip_synth:
    default: false
    description: Skip synthesis of the application, assume the synthesized Terraform code is already present and up to date
  artifact_name:
    description: When given, attempt to download the given artifact contents into this working directory.
outputs:
  html_url:
    description: Direct link to this job, which shows the full execution output.
    value: ${{ steps.jobid_action.outputs.html_url }}
  job_id:
    description: ID of this job
    value: ${{ steps.jobid_action.outputs.job_id }}
  result_code:
    description: Similar to exitcode behavior for Terraform, not yet supported by CDKTF.  0 = Succeeded with empty diff (no changes), 1 = Error, 2 = Succeeded with non-empty diff (changes present)
    value: ${{ steps.diff.outputs.result_code }}
  stack:
    description: Full name of the CDKTF stack used for the diff.
    value: ${{ inputs.stack }}
  summary:
    description: Single string of output to summarize the results.
    value: ${{ steps.diff.outputs.summary }}
runs:
  using: composite
  steps:
    - name: Retrieve Job ID with Pagination
      id: jobid_action
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        JOB_NAME: ${{ inputs.job_name }}
      run: |
        # We'll fetch pages of jobs and look for the one that matches JOB_NAME.
        found_job_id=''
        page=1

        while [ -z "$found_job_id" ]; do
          echo "Fetching page $page of jobs."
          # Get both the response body and Link header in one request
          response=$(curl --fail-with-body -s -D - -H "Accept: application/vnd.github.v3+json" \
                        -H "Authorization: Bearer $GITHUB_TOKEN" \
                        "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs?per_page=100&page=${page}")
                    
          # Extract the JSON body everything after the blank line after headers.
          json_response=$(echo "$response" | awk -v RS='\r\n\r\n' 'END{print}')
          
          # Use jq to try to find the job ID for the matching name
          found_job_id=$(echo "$json_response" | jq -r --arg jobName "$JOB_NAME" '.jobs[] | select(.name == $jobName) | .id')
          if [ -n "$found_job_id" ] && [ "$found_job_id" != "null" ]; then
            # If found, also grab the html_url
            found_html_url=$(echo "$json_response" | jq -r --arg jobName "$JOB_NAME" '.jobs[] | select(.name == $jobName) | .html_url')
            
            echo "Found job with name: $JOB_NAME, ID: $found_job_id"
            echo "job_id=$found_job_id" >> $GITHUB_OUTPUT
            echo "html_url=$found_html_url" >> $GITHUB_OUTPUT
            break
          fi
          link_header=$(echo "$response" | grep -i ^Link: || true)
          # Extract the Link header and check If there's no 'next' link in the headers. We've reached the end.
          if [[ "$link_header" != *'rel="next"'* ]]; then
            echo "Could not find the job with name $JOB_NAME after paginating."
            exit 1
          fi

          page=$((page + 1))
        done

    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ inputs.terraform_version }}

    - uses: actions/checkout@v4
      id: checkout
      with:
        fetch-depth: 0
        ref: ${{ inputs.ref }}

    - name: Load Configuration
      id: configurations
      shell: bash
      run: |
        cd ${{ inputs.working_directory }}
        echo "node_version=$(cat .nvmrc)" >> $GITHUB_OUTPUT

    - uses: actions/setup-node@v4
      with:
        node-version: ${{ steps.configurations.outputs.node_version }}

    - name: Install Node Dependencies
      shell: bash
      run: |
        cd ${{ inputs.working_directory }}
        npm ci

    - name: Download Artifact Files
      if: ${{ inputs.artifact_name }}
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.artifact_name }}
        path: ${{ inputs.working_directory }}/cdktf.out

    - name: Run Diff
      id: diff
      shell: bash
      run: |
        cd ${{ inputs.working_directory }}

        # Initialize default outputs in case of failure
        echo "result_code=1" >> $GITHUB_OUTPUT
        echo "summary=Error: Diff execution failed" >> $GITHUB_OUTPUT

        # If stub_output_file is present, set the execution command to output this file instead of running diff.
        # Assignment uses single quotes explicitly to prevent possible code injection.
        if [ -f "${{ inputs.stub_output_file }}" ]; then
          DIFF_COMMAND='cat ${{ inputs.stub_output_file }} | perl -pe "select undef,undef,undef,.05"'
        else
          DIFF_COMMAND='CI=1 npx cdktf diff'
        fi

        # If skip_synth is set to true, add --skip-synth to the command options.
        if [ "${{ inputs.skip_synth }}" == "true" ]; then
          DIFF_COMMAND="$DIFF_COMMAND --skip-synth"
        fi

        DIFF_COMMAND="$DIFF_COMMAND ${{ inputs.stack }}"

        # show output in CLI/GitHub and also send to file for later parsing
        DIFF_FILE_PATH="${TMPDIR}cdktf-diff.txt"

        # Run the command and capture exit code, but don't fail the step yet
        set +e
        eval $DIFF_COMMAND 2>&1 | tee $DIFF_FILE_PATH
        DIFF_EXIT_CODE=${PIPESTATUS[0]}
        set -e

        # Check if the diff file was created and has content
        if [ ! -f "$DIFF_FILE_PATH" ] || [ ! -s "$DIFF_FILE_PATH" ]; then
          echo "result_code=1" >> $GITHUB_OUTPUT
          echo "summary=Error: Diff command failed before producing output" >> $GITHUB_OUTPUT
          exit 0 # exit with 0 so subsequent steps can run
        fi

        # If planning failed due to an error, set the outputs and return.
        if cat $DIFF_FILE_PATH | sed -r "s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | grep "Planning failed. Terraform encountered an error while generating this plan." > /dev/null ; then
          echo "result_code=1" >> $GITHUB_OUTPUT
          SUMMARY=$(cat $DIFF_FILE_PATH | grep "Error: " | head -1 | sed -r "s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | sed 's/^[[:space:]]*│[[:space:]]*//' | xargs)
          if [ -z "$SUMMARY" ]; then
            SUMMARY="Planning failed. Terraform encountered an error while generating this plan."
          fi
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
          exit 0 # return code zero so we don't break the rest of the workflow
        fi        

        # If there are no changes, set the outputs and return.
        if cat $DIFF_FILE_PATH | sed -r "s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | grep "No changes. Your infrastructure matches the configuration." > /dev/null ; then
          SUMMARY="No changes. Your infrastructure matches the configuration."
          echo "result_code=0" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
          exit 0
        fi

        # If there is a plan, set the outputs and return.
        if cat $DIFF_FILE_PATH | sed -r "s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | grep "Plan:" > /dev/null ; then
          echo "result_code=2" >> $GITHUB_OUTPUT
          SUMMARY=$(cat $DIFF_FILE_PATH | grep "Plan:" | sed -r "s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | sed 's/.*Plan:/Plan:/' | xargs)
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
          exit 0 # return code zero so we don't break the rest of the workflow
        fi

        # If command failed but we couldn't parse the output, try to extract error message
        if [ $DIFF_EXIT_CODE -ne 0 ]; then
          echo "result_code=1" >> $GITHUB_OUTPUT
          # Try to extract error message from the output
          ERROR_MSG=$(cat $DIFF_FILE_PATH | grep -i "Error:" | head -1 | sed -r "s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | sed 's/^[[:space:]]*│[[:space:]]*//' | xargs || true)
          if [ -n "$ERROR_MSG" ]; then
            echo "summary=$ERROR_MSG" >> $GITHUB_OUTPUT
          else
            # Fallback: get last few lines that might contain error info
            ERROR_MSG=$(tail -5 $DIFF_FILE_PATH | sed -r "s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | sed 's/^[[:space:]]*│[[:space:]]*//' | tr '\n' ' ' | xargs || true)
            if [ -n "$ERROR_MSG" ]; then
              echo "summary=$ERROR_MSG" >> $GITHUB_OUTPUT
            else
              echo "summary=Error: Diff command failed with exit code $DIFF_EXIT_CODE" >> $GITHUB_OUTPUT
            fi
          fi
          exit 0 # exit with 0 so subsequent steps can run
        fi

        # If we get here, we couldn't determine the result
        echo "result_code=1" >> $GITHUB_OUTPUT
        echo "summary=Error: Could not determine if diff ran successfully" >> $GITHUB_OUTPUT
        exit 0 # exit with 0 so subsequent steps can run

    - name: Dump Outputs to File
      if: always()
      shell: bash
      run: |
        # Set default values if outputs are not set (e.g., if diff step failed before setting them)
        RESULT_CODE="${{ steps.diff.outputs.result_code }}"
        SUMMARY="${{ steps.diff.outputs.summary }}"
        HTML_URL="${{ steps.jobid_action.outputs.html_url }}"
        JOB_ID="${{ steps.jobid_action.outputs.job_id }}"
        NODE_VERSION="${{ steps.configurations.outputs.node_version }}"
        TERRAFORM_VERSION="${{ inputs.terraform_version }}"
        STACK="${{ inputs.stack }}"

        # Use defaults if values are empty
        if [ -z "$RESULT_CODE" ]; then
          RESULT_CODE="1"
        fi
        if [ -z "$SUMMARY" ]; then
          SUMMARY="Error: Job failed before outputs could be determined"
        fi
        if [ -z "$HTML_URL" ]; then
          HTML_URL=""
        fi
        if [ -z "$JOB_ID" ]; then
          JOB_ID=""
        fi
        if [ -z "$NODE_VERSION" ]; then
          NODE_VERSION=""
        fi

        # Escape quotes in summary for JSON
        SUMMARY_ESCAPED=$(echo "$SUMMARY" | sed 's/"/\\"/g')

        # Create JSON output
        TOTAL_OUTPUTS="{\"result_code\":${RESULT_CODE},\"summary\":\"${SUMMARY_ESCAPED}\",\"html_url\":\"${HTML_URL}\",\"stack\":\"${STACK}\",\"job_id\":\"${JOB_ID}\",\"node_version\":\"${NODE_VERSION}\",\"terraform_version\":\"${TERRAFORM_VERSION}\"}"
        echo $TOTAL_OUTPUTS > ${{ inputs.working_directory }}/${{ inputs.output_filename }}

    - uses: actions/upload-artifact@v4
      if: always()
      name: Save Outputs
      with:
        name: ${{ steps.jobid_action.outputs.job_id }}
        path: ${{ inputs.working_directory }}/${{ inputs.output_filename }}
